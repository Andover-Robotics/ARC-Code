#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Motor,  mtr_S1_C1_1,     L,             tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     R,             tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     belt,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     slide,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     sweep,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     none,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    release,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "JoystickDriver.c"
//Define Constants
#define WHEEL_CIRCUMFERENCE 21.99
#define WHEEL_RADIUS 3.5
#define DISTANCE_FROM_START_TO_60CM_GOAL_IN_TICKS 13751
#define REVOLUTION 1440
//The 4 Direction Options, direction is angle relative to the robot's current //position. I.E. 0 -> Straight ahead, 90 -> 90 degrees (left) of robot ...
#define FORWARD 0
#define BACKWARDS 180
#define LEFT 90
#define RIGHT -90

void turn (int dir_)
{
	int angle = abs (dir_);

	if (dir_ < 0)
	{
		float cm = (2*pi*WHEEL_RADIUS) * angle/360;
		int ticks = ((cm *1440)/(WHEEL_CIRCUMFERENCE);
		nMotorEncoderTarget[L] = -ticks;
		nMotorEncoderTarget [R] = ticks;
		motor[L] = -50;
		motor[R] = 50;
	}
	if (dir_ > 0)
	{
		float cm = (2*pi*WHEEL_RADIUS) * angle/360;
		int ticks = (1440/(21.9911485751/cm);
		nMotorEncoderTarget[L] = ticks;
		nMotorEncoderTarget [R] = -ticks;
		motor[L] = 50;
		motor[R] = -50;
	}



}



//Amount of torque produced by tetrix motor -- assume full power
#define MOTOR_TORQUE __________________

//The radius of the robot
#define RADIUS ___________________

//Define Util functions

//Resets all encoders, and stops motors
void clear () {
   //TODO Clear all motor encoders, and stop all motors
}

//Conversion factor between ticks and cm
//ticks = cm * tickRatio
float tickRatio;

//Converts given distance (cm) into ticks, rounding to the nearest integer, and //returns the result
int convertToTicks (int cm) {
   return (int) (cm * tickRatio + 0.5);
}

//Turns through the given angle (degrees).
//Positive Angle -> LEFT
//Negative Angle -> RIGHT



//Moves the robot in given direction (relative to its current direction) for given //distance (cm)
//TODO  pid adjustments for tetrix motors
void move(int direction,int distance) {
   turn(direction);
   int ticks = convertToTicks(distance);
   clear();

   while (nMotorEncoder[RIGHT_MOTOR] != ticks) {
      motor[RIGHT] = 50;
      motor[LEFT] = 50;
   }

   clear();
}

//Define strategy

//Initialize all necessary fields and set mechanical components to their inital //positions
void initialization () {
   //TODO
}

//Executes the autonomous logic
void run () {

}

/* OUTDATED IR STUFF
   //Ramp Version
   
   //Lower Area Version
   {
      Move Forward
      if IR Beacon is in Sector 5 then
         int a  = ; //The Amount of ticks to move
         int b = ;
         move(LEFT,a);
         move(UP,b);
         
         //*Knocks over pole*
      else
         int a = ;
         int b = ;
         move(LEFT,a);
         move(UP,b);
         turn(RIGHT);
         
         if IR Beacon is in Sector 5 then
            turn(RIGHT);
            int c = ;
            int d = ; //d ~= a, but maybe is slightly bigger
            move(DOWN,c);
            move(RIGHT,d);
            
            //*Knocks over pole*
         else
            int c = ;
            int d = ;
            move(RIGHT,c);
            move(135, d);
   }
   
*/
}

task main {
   //waitForStart();
//The linear slide is raised
 			nMotorEncoder[slide] = 0;
 			nMotorEncoderTarget[slide] = 3 * REVOLUTION;
			motor[slide] = 30;
			
 	 //The motor encoders are reset
 			nMotorEncoder[L] = 0;
 			nMotorEncoder[R] = 0;
 			
 	 //The motors' target is set
 			nMotorEncoderTarget[L] = DISTANCE_FROM_START_TO_60CM_GOAL_IN_TICKS;
 			nMotorEncoderTarget[R] = DISTANCE_FROM_START_TO_60CM_GOAL_IN_TICKS;
 	 
 	 //The motors run until target is reached
 			motor[L] = 50;
 			motor[R] = 50;
 			
 	 //The motor encoders are reset
 			nMotorEncoder[L] = 0;
 			nMotorEncoder[R] = 0;
 			
 	 //The goal mechanism is attatched to the 60cm goal		
 			servo[release] += 240; //170 degrees represented in servo positional value
 			
 	 //The robot attempts to score a ball into the 60cm goal
 			nMotorEncoderTarget[belt] = 0;
 			nMotorEncoderTarget[belt] = 0.5 * REVOLUTION;
 			motor[belt] = 18;
 			
 	 /*The robot turns the amount of degrees in the angle formed by the wall up until the 60cm goal, 
 	 and the auxillary line from the4 goal to the parking zone*/
 			turn(50); //absolute guess
 			
 	 //The robot moves to the parking zone
 			nMotorEncoderTarget[L] = 1234; //unknown; distance from 60cm goal to parking zone in ticks
 			nMotorEncoderTarget[R] = 1234; //^


}

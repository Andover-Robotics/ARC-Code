//<snip Pragma initialization>

#include "JoystickDriver.c"

//Define Constants

//The 4 Direction Options, direction is angle relative to the robot's current //position. I.E. 0 -> Straight ahead, 90 -> 90 degrees (left) of robot ...
#define FORWARD 0
#define BACKWARDS 180
#define LEFT 90
#define RIGHT -90

//Amount of torque produced by tetrix motor -- assume full power
#define MOTOR_TORQUE __________________

//The radius of the robot
#define RADIUS ___________________

//Define Util functions

//Resets all encoders, and stops motors
void clear () {
   //TODO Clear all motor encoders, and stop all motors
}

//Conversion factor between ticks and cm
//ticks = cm * tickRatio
float tickRatio;

//Converts given distance (cm) into ticks, rounding to the nearest integer, and //returns the result
int convertToTicks (int cm) {
   return (int) (cm * tickRatio + 0.5);
}

//Moves the robot in given direction (relative to its current direction) for given //distance (cm)
//TODO  pid adjustments for tetrix motors
void move(int direction,int distance) {
   turn(direction);
   int ticks = convertToTicks(distance);
   clear();

   while (nMotorEncoder[RIGHT_MOTOR] != ticks) {
      motor[RIGHT] = 50;
      motor[LEFT] = 50;
   }

   clear();
}

//Define strategy

//Initialize all necessary fields and set mechanical components to their inital //positions
void initialization () {
   //TODO
}

//Executes the autonomous logic
void run () {
 
   //Safi's Thing:
   //The linear slide is raised
 			nMotorEncoder[slide] = 0;
 			nMotorEncoderTarget[slide] = ???;
			motor[slide] = 30;
			
 	 //The motor encoders are reset
 			nMotorEncoder[L] = 0;
 			nMotorEncoder[R] = 0;
 			
 	 //The motors' target is set
 			nMotorEncoderTarget[L] = 13750.56;
 			nMotorEncoderTarget[R] = 13750.56;
 	 
 	 //The motors run until target is reached
 			motor[L] = 50;
 			motor[R] = 50;
 			
 	 //The motor encoders are reset
 			nMotorEncoder[L] = 0;
 			nMotorEncoder[R] = 0;
 			
 	 //The goal mechanism is attatched		
 			servo[release] += 1;
 			
 	 //It turns left and motors run
 			turn(90);
 			motor[L] = 50;
 			motor[R] = 50;
 			wait10Msec(50) //guess
 			
 	 //The motors' target is set
 			nMotorEncoderTarget[L] = 13750.56;
 			nMotorEncoderTarget[R] = 13750.56;
 			
 	 //It turns left and motors run until target is reached
 			turn(90);
 			motor[L] = 50;
 			motor[R] = 50;
  
 	 //It turns right and motors run
			turn(-90);
 			motor[L] = 50;
 			motor[R] = 50;
 			wait10Msec(150) //guess
 			
 		

			
}

/* OUTDATED IR STUFF
   //Ramp Version
   
   //Lower Area Version
   {
      Move Forward
      if IR Beacon is in Sector 5 then
         int a  = ; //The Amount of ticks to move
         int b = ;
         move(LEFT,a);
         move(UP,b);
         
         //*Knocks over pole*
      else
         int a = ;
         int b = ;
         move(LEFT,a);
         move(UP,b);
         turn(RIGHT);
         
         if IR Beacon is in Sector 5 then
            turn(RIGHT);
            int c = ;
            int d = ; //d ~= a, but maybe is slightly bigger
            move(DOWN,c);
            move(RIGHT,d);
            
            //*Knocks over pole*
         else
            int c = ;
            int d = ;
            move(RIGHT,c);
            move(135, d);
   }
   
*/
}

task main {
   waitForStart();
}

#pragma config(Hubs,  S2, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ColorSensor,    sensorI2CHiTechnicColor)
#pragma config(Motor,  mtr_S2_C1_1,     L,             tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     R,             tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C3_1,     LinearSlide,   tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C3_2,     ArmMotor,      tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    ArmJoint,             tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    ArmExtend,            tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int ipt = 8.25;                                  			//inches driven per 1 thousand ticks
int hexagonSide = 40;                   	    			//hexagon around center goal has side length 40 inches
int hexagonAngle = 120;                               			//hexagon has interior angles of 120 degrees;

void clear(){                                         			//clears all encoders
  nMotorEncoder[L] = 0;
  nMotorEncoder[R] = 0;
  nMotorEncoder[LinearSlide] = 0;
  nMotorEncoder[ArmMotor] = 0;
} 
void driveStraight(int in){                           			//function which drives straight distance in
  while(nMotorEncoder[L] < (in/ipt) * 1000            			//while the encoders read less than (desired inches*1000 ticks/ipt)
    && in >= 0){                                      			//on the condition that the number of inches desired is greater/equal to zero
      motor[L] = 80;                                  			//run left motor at 80% power
      motor[R] = 80;                                  			//run right motor at 80% power
    }
  while(nMotorEncoder[L] > (in/ipt) * 1000            			//while the encoders read greater than (desired inches*1000 ticks/ipt)
    && in < 0){                                       			//on the condition that the number of inches desired is less than 0)
      motor[L] = -80;                                 			//run left motor in reverse at 80% power
      motor[R] = -80;                                 			//run right motor in reverse at 80% power
    }
  motor[L] = 0;                                       			//Stops left motor
  motor[R] = 0;                                       			//Stops right motor 
  wait10Msec(100);                                    			//waits .1 seconds
  clear();                                            			//clears encoders
}	
void turn(int deg){                                   			//function for turning # of degrees, deg
  while(nMotorEncoder[R] < (deg*15.87)                			//while the encoder does not read the desired value of (deg/360)*(15pi in/ipt)*1000ticks
    && deg > 0){                                      			//on the condition that the angle desired is positive
      motor[R] = 70;                                  			//runs right motor at 70% power
      motor[L] = -70;                                 			//runs left motor at -70% power
    }	
  while(nMotorEncoder[R] > (deg*15.87)                			//while the encoder does not read the desired value of (deg/360)*(15pi in/ipt)*1000ticks
    && deg < 0){                                      			//on the condition that the angle desired is positive
      motor[R] = -70;                                 			//runs right motor at -70% power
      motor[L] = 70;                                  			//runs left motor at 70% power
    }
}
task main(){
  clear();
  drive(-72);
  for(int i = 0; i < 2880; i += 4){
    nMotorEncoderTarget[ArmMotor] = i;
    motor[ArmMotor] = 80;
    servo[ArmJoint] += 1;
  }
}

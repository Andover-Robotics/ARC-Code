#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S2,     EOPD,           sensorAnalogActive)
#pragma config(Sensor, S3,     IRSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     L,             tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     R,             tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     LinearSlide,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     ArmMotor,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Hook,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    ArmJoint,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    EOPDservo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    autoArm,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
FTC 2014-15
Cascade Effect
Team 4410 ARC Lightning
Autonomous Code
Christopher Zhao
version 1.0, 2/10/2015
*/

#include "JoystickDriver.c"
#include "hitechnic-gyro.h"
#include "hitechnic-eopd.h"
#include "lego-ultrasound.h"

float ipt = 12;//8.7266463;																	//inches driven per 1 thousand ticks																								Test this value, should be more accurate
int linearTicks = 2903;																			//number of ticks to raise linear slide
int armTicks = 12;																					//number of ticks to raise arm 1 degree
bool IRDetection = false;																		//denotes whether or not IR has been detected

//buttons
int buttonRight = 1;
int buttonLeft = 2;
int buttonEnter = 3;

void stopMotors(){
	motor[L] = 0;
	motor[R] = 0;
	motor[LinearSlide] = 0;
	motor[ArmMotor] = 0;
}
void clear(){                                         			//clears all encoders
  nMotorEncoder[L] = 0;
  nMotorEncoder[R] = 0;
  nMotorEncoder[LinearSlide] = 0;
  nMotorEncoder[ArmMotor] = 0;
}
void driveStraight(int in){                           			//function which drives straight distance in
  while(nMotorEncoder[L] < (in/ipt) * 1000            			//while the encoders read less than (desired inches*1000 ticks/ipt)
    && in >= 0){                                      			//on the condition that the number of inches desired is greater/equal to zero
      motor[L] = 80;                                  			//run left motor at 80% power
      motor[R] = 80;                                  			//run right motor at 80% power
    }
  while(nMotorEncoder[L] > (in/ipt) * 1000            			//while the encoders read greater than (desired inches*1000 ticks/ipt)
    && in < 0){                                       			//on the condition that the number of inches desired is less than 0)
      motor[L] = -80;                                 			//run left motor in reverse at 80% power
      motor[R] = -80;                                 			//run right motor in reverse at 80% power
    }
  motor[L] = 0;                                       			//Stops left motor
  motor[R] = 0;                                       			//Stops right motor
  wait10Msec(10);	                                    			//waits .1 seconds
  clear();                                            			//clears encoders
}
void driveFullPwr(int in){
	while(nMotorEncoder[L] < (in/ipt) * 1000            			//while the encoders read less than (desired inches*1000 ticks/ipt)
    && in >= 0){                                      			//on the condition that the number of inches desired is greater/equal to zero
      motor[L] = 100;                                  			//run left motor at 80% power
      motor[R] = 100;                                  			//run right motor at 80% power
    }
  while(nMotorEncoder[L] > (in/ipt) * 1000            			//while the encoders read greater than (desired inches*1000 ticks/ipt)
    && in < 0){                                       			//on the condition that the number of inches desired is less than 0)
      motor[L] = -100;                                 			//run left motor in reverse at 80% power
      motor[R] = -100;                                 			//run right motor in reverse at 80% power
    }
  motor[L] = 0;                                       			//Stops left motor
  motor[R] = 0;                                       			//Stops right motor
  wait10Msec(10);	                                    			//waits .1 seconds
  clear();                                            			//clears encoders
}
void hardTurn(int deg){                                   	//function for turning # of degrees, deg
  while(nMotorEncoder[L] < (deg*21)		           						//while the encoder does not read the desired value of (deg/360)*(15pi in/ipt)*1000ticks
    && deg > 0){                                      			//on the condition that the angle desired is positive
      motor[R] = 70;                                  			//runs right motor at 70% power
      motor[L] = -70;                                 			//runs left motor at -70% power
    }
  while(nMotorEncoder[L] > (deg*21)		                			//while the encoder does not read the desired value of (deg/360)*(15pi in/ipt)*1000ticks
    && deg < 0){                                      			//on the condition that the angle desired is positive
      motor[R] = -70;                                 			//runs right motor at -70% power
      motor[L] = 70;                                  			//runs left motor at 70% power
    }
   stopMotors();
}
void raiseLinearSlide(float per){
	while(nMotorEncoder[LinearSlide] < per * linearTicks
		&& per > 0){
			motor[LinearSlide] = 80;
	}
	while(nMotorEncoder[LinearSlide] > per * linearTicks
		&& per < 0){
			motor[LinearSlide] = -80;
		}
	motor[LinearSlide] = 0;
	clear();
}
void raiseArm(){
	for(int x = 0; x < 3; x++){
		clear();
		nMotorEncoderTarget[ArmMotor] = 360;
		motor[ArmMotor] = 80;
		servo[ArmJoint] += -20;
	}
	motor[ArmMotor] = 0;
}
void lowerArm(){
	for(int x = 0; x < 3; x++){
		clear();
		nMotorEncoderTarget[ArmMotor] = -360;
		motor[ArmMotor] = -80;
		servo[ArmJoint] += 20;
	}
	motor[ArmMotor] = 0;
}
void raiseArmFull(){
	for(int x = 0; x < 4; x++){
		clear();
		nMotorEncoderTarget[ArmMotor] = 360;
		motor[ArmMotor] = 80;
		servo[ArmJoint] += -20;
	}
	motor[ArmMotor] = 0;
}
void tRaiseArm(){
	for(int x = 0; x < 3; x++){
		motor[ArmMotor] = 80;
		servo[ArmJoint] += -20;
		wait10Msec(120);
	}
	motor[ArmMotor] = 0;
	clear();
}
void tLowerArm(){
	for(int x = 0; x < 3; x++){
		motor[ArmMotor] = -80;
		servo[ArmJoint] += 20;
		wait10Msec(110);
	}
	motor[ArmMotor] = 0;
	clear();
}
void initiallize(){
	servoChangeRate[ArmJoint] = 2;
	servoChangeRate[Hook] = 9;
	servo[ArmJoint] = 240;
	servo[Hook] = 0;
	servo[autoArm] = 254;
	clear();
	waitForStart();
}
void IRDrive(int in){																					//drives robot a set distance or until IR is detected, does not drive when IR already found
	while(nMotorEncoder[L] < (in/ipt)*1000
			&& SensorValue[IRSensor] != 5 ){												//while the encoder is less than 1000 * desired inches/inches per thousand
			motor[L] = 80;																					//Left motor drive forward
			motor[R] = 80;																					//Right motor drive forward
		}
	motor[L] = 0;																								//stop Left motor
	motor[R] = 0;																								//stop Right motor
	if(SensorValue[IRSensor] == 5){
		IRDetection = true;
	}
	clear();
}
task main()
{
	bool taskBool[6];                                   				//Determines whether or not a certain task gets enacted
	taskBool[5] = false;
	string taskList[4] =
	  {"Starting Area", "Goal Type", "Kickstand", "Drag"};     	//List of different tasks
	string taskOption[4][2];
	taskOption[0][0] = "Ramp";
	taskOption[0][1] = "Parking Zone";
	taskOption[1][0] = "Rolling";
	taskOption[1][1] = "Center";
	taskOption[2][0] = "Yes";
	taskOption[2][1] = "No";
	taskOption[3][0] = "Yes";
	taskOption[3][1] = "No";
	short taskNumber = 0;
	short taskOptionNumber = 0;
	while(taskNumber < 3){
		nxtDisplayCenteredTextLine(3, "%s", 
			taskList[taskNumber]);
		nxtDisplayCenteredTextLine(5, "%s", 
			taskOption[taskNumber][taskOptionNumber]);
		if(nNxtButtonPressed == buttonRight){
			taskOptionNumber = 1;
		}
		if(nNxtButtonPressed == buttonLeft){
			taskOptionNumber = 0;
		}
		if(nNxtButtonPressed == buttonEnter && 
			taskOptionNumber == 0){
				taskBool[taskNumber] = true;
				taskNumber++;
				wait10Msec(100);
		}
		if(nNxtButtonPressed == buttonEnter &&
			taskOptionNumber == 1){
				taskBool[taskNumber] = false;	
				taskNumber++;
				wait10Msec(100);
		}
		if(nNxtButtonPressed == -1){}
	}
	if(taskBool[3] == true){
		taskBool[4] = false;
		taskBool[5] = true;
	}
	while(taskBool[3] == true && taskBool[5] == false){
		nxtDisplayCenteredTextLine(3, "%s", taskList[3]);
		nxtDisplayCenteredTextLine(5, "%s", taskOption[3][taskOptionNumber]);
		if(nNxtButtonPressed == buttonRight){
			taskOptionNumber = 1;
		}
		if(nNxtButtonPressed == buttonLeft){
			taskOptionNumber = 0;
		}
		if(nNxtButtonPressed == buttonEnter && 
			taskOptionNumber == 0){
				taskBool[4] = true;
				wait10Msec(100);
				taskBool[5] = true;
		}
		if(nNxtButtonPressed == buttonEnter &&
			taskOptionNumber == 1){
				taskBool[4] = false;	
				wait10Msec(100);
				taskBool[5] = true;
		}
		if(nNxtButtonPressed == -1){}
	}
	if(taskBool[5] == true){}
	//ready, begin autonomous procedure
	initiallize();
}

#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     L,             tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     R,             tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     LinearSlide,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     ArmMotor,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Hook,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    ArmJoint,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    autoArm,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
FTC 2014-15
Cascade Effect
Team 4410 ARC Lightning
Autonomous Code
Christopher Zhao
version .9, 1/22/2015
*/

#include "JoystickDriver.c"

float ipt = 12;//8.7266463;																	//inches driven per 1 thousand ticks
//int octagonSide = 20;                   	   							//hexagon around center goal has side length 40 inches
//int octagonAngle = 135;                               		//hexagon has interior angles of 120 degrees
int linearTicks = 2903;																			//number of ticks to raise linear slide
int armTicks = 12;																					//number of ticks to raise arm 1 degree
bool IRDetection = false;																		//denotes whether or not IR has been detected

void clear(){                                         			//clears all encoders
  nMotorEncoder[L] = 0;
  nMotorEncoder[R] = 0;
  nMotorEncoder[LinearSlide] = 0;
}
void driveStraight(int in){                           			//function which drives straight distance in
  while(nMotorEncoder[L] < (in/ipt) * 1000            			//while the encoders read less than (desired inches*1000 ticks/ipt)
    && in >= 0){                                      			//on the condition that the number of inches desired is greater/equal to zero
      motor[L] = 80;                                  			//run left motor at 80% power
      motor[R] = 80;                                  			//run right motor at 80% power
    }
  while(nMotorEncoder[L] > (in/ipt) * 1000            			//while the encoders read greater than (desired inches*1000 ticks/ipt)
    && in < 0){                                       			//on the condition that the number of inches desired is less than 0)
      motor[L] = -80;                                 			//run left motor in reverse at 80% power
      motor[R] = -80;                                 			//run right motor in reverse at 80% power
    }
  motor[L] = 0;                                       			//Stops left motor
  motor[R] = 0;                                       			//Stops right motor
  wait10Msec(10);	                                    			//waits .1 seconds
  clear();                                            			//clears encoders
}
void driveFullPwr(int in){
	while(nMotorEncoder[L] < (in/ipt) * 1000            			//while the encoders read less than (desired inches*1000 ticks/ipt)
    && in >= 0){                                      			//on the condition that the number of inches desired is greater/equal to zero
      motor[L] = 100;                                  			//run left motor at 80% power
      motor[R] = 100;                                  			//run right motor at 80% power
    }
  while(nMotorEncoder[L] > (in/ipt) * 1000            			//while the encoders read greater than (desired inches*1000 ticks/ipt)
    && in < 0){                                       			//on the condition that the number of inches desired is less than 0)
      motor[L] = -100;                                 			//run left motor in reverse at 80% power
      motor[R] = -100;                                 			//run right motor in reverse at 80% power
    }
  motor[L] = 0;                                       			//Stops left motor
  motor[R] = 0;                                       			//Stops right motor
  wait10Msec(10);	                                    			//waits .1 seconds
  clear();                                            			//clears encoders
}
void turn(int deg){                                   			//function for turning # of degrees, deg
  while(nMotorEncoder[R] < (deg*15.5)		           					//while the encoder does not read the desired value of (deg/360)*(15pi in/ipt)*1000ticks
    && deg > 0){                                      			//on the condition that the angle desired is positive
      motor[R] = 70;                                  			//runs right motor at 70% power
      motor[L] = -70;                                 			//runs left motor at -70% power
    }
  while(nMotorEncoder[L] < -(deg*21)                			//while the encoder does not read the desired value of (deg/360)*(15pi in/ipt)*1000ticks
    && deg < 0){                                      			//on the condition that the angle desired is positive
      motor[R] = -70;                                 			//runs right motor at -70% power
      motor[L] = 70;                                  			//runs left motor at 70% power
    }
   motor[L] = 0;
   motor[R] = 0;
   wait10Msec(10);
   clear();
}
void raiseLinearSlide(float per){
	while(nMotorEncoder[LinearSlide] < per * linearTicks
		&& per > 0){
			motor[LinearSlide] = 80;
	}
	while(nMotorEncoder[LinearSlide] > per * linearTicks
		&& per < 0){
			motor[LinearSlide] = -80;
		}
	motor[LinearSlide] = 0;
	clear();
}
void raiseArm(){
	for(i = 0; i < 3; i++){
		clear();
		nMotorEncoderTarget[ArmMotor] = 360;
		motor[ArmMotor] = 80;
		servo[ArmJoint] += -20;
	}
	motor[ArmMotor] = 0;
}
void lowerArm(){
	for(i = 0; i < 3; i++){
		clear();
		nMotorEncoderTarget[ArmMotor] = -360;
		motor[ArmMotor] = -80;
		servo[ArmJoint] += 20;
	}
	motor[ArmMotor] = 0;
}
void raiseArmFull(){
	for(i = 0; i < 4; i++){
		clear();
		nMotorEncoderTarget[ArmMotor] = 360;
		motor[ArmMotor] = 80;
		servo[ArmJoint] += -20;
	}
	motor[ArmMotor] = 0;
}
/*void gui(){
	bool taskBool[4];                                   			//Determines whether or not a certain task gets enacted
	string taskList[] =
	  {"Ramp", "IR", "Regular Tube", "Kickstand"};      	   	//List of different tasks
	int i = 0;                                          	   	//denotes how many tasks have been decided upon by the user
	while(i < 3){						   																//while number of tasks decided on is less than total number of tasks
		nxtDisplayCenteredTextLine(3, "%s", taskList[i]);  			//Display the name of task being decided on
		wait10Msec(100);
		if(nNxtButtonPressed == 1){                        			//If the left arrow is pressed
			nxtDisplayCenteredTextLine(5, "Yes");      						//Display "true" on NXT
			taskBool[i] = true;                        						//Set the decision to true
		}
		else{}
		if(nNxtButtonPressed == 2){                       			//If the right arrow is pressed
			nxtDisplayCenteredTextLine(5, "No");            			//Display "false" on the NXT
			taskBool[i] = false;                            			//Set the decision to false
		}
		else{}
		if(nNxtButtonPressed == 3){                       			//If the center button is pressed, confirm the decision
			eraseDisplay();                                 			//clear the display
			i = i + 1;                                      			//Move on to next decision
		}
		else{}
	}
}*/
void tRaiseArm(){
	for(int i = 0; i < 3; i++){
		motor[ArmMotor] = 80;
		servo[ArmJoint] += -20;
		wait10Msec(120);
	}
	motor[ArmMotor] = 0;
	clear();
}
void tLowerArm(){
	for(int i = 0; i < 3; i++){
		motor[ArmMotor] = -80;
		servo[ArmJoint] += 20;
		wait10Msec(110);
	}
	motor[ArmMotor] = 0;
	clear();
}
void initiallize(){
	servoChangeRate[ArmJoint] = 2;
	servoChangeRate[Hook] = 9;
	servo[ArmJoint] = 240;
	servo[Hook] = 0;
	clear();
	waitForStart();
}
void IRDrive(int in){																					//drives robot a set distance or until IR is detected, does not drive when IR already found
	while(nMotorEncoder[L] < (in/ipt)*1000
			&& SensorValue[IRSensor] != 5 ){												//while the encoder is less than 1000 * desired inches/inches per thousand
			motor[L] = 80;																					//Left motor drive forward
			motor[R] = 80;																					//Right motor drive forward
		}
	motor[L] = 0;																								//stop Left motor
	motor[R] = 0;																								//stop Right motor
	if(SensorValue[IRSensor] == 5){
		IRDetection = true;
	}
	clear();
}
task main(){
	initiallize();
  raiseArm();
  driveStraight(/*77.5*/);		//remeasure
  raiseLinearSlide(1);
  servo[ArmJoint] = 0;
  wait10Msec(300);
  servo[ArmJoint] = 180;
  lowerArm();
  raiseLinearSlide(-0.9);
	driveStraight(/*-7.5*/);		//remeasure
  turn(90);
  driveStraight(/*24*/);			//remeasure
  turn(-90);
  driveStraight(-24);
  turn(-90);
  driveStraight(-10);
  IRDrive(-3);
  if(IRDetection == false){
  	turn(-45);
  	IRDrive(-5);
  }
  if(IRDetection == false){
 		turn(-45);
 		IRDrive(-5);
 	}	
 	if(IRDetection == true){
 		turn(-90);
 		raiseArmFull();
 		driveStraight(10);
 		
 	}
}
